---
title: "flat_money_transfer.Rmd for working package"
output: html_document
editor_options: 
  chunk_output_type: console
---



# This is the documentation of all functions of the package

```{r development-dataset}
# Run all this chunk in the console directly
# There already is a dataset in the "inst/" directory
# Make the dataset file available to the current Rmd during development
pkgload::load_all(path = here::here(), export_all = FALSE)

```


## Function to read costs file
This is a helper function that reads in the data from the participant file.
```{r function-read_costs}
#' Read Cost Data from CSV File
#'
#' This function reads cost data from a CSV file, defaulting to the "costs.csv" 
#' file included in the dividefair package.
#'
#' @param path A character string specifying the path to the CSV file. 
#'   Defaults to the "costs.csv" file included in the dividefair package.
#'
#' @return A tibble containing the cost data read from the CSV file.
#'
#' @importFrom readr read_csv
#'
#' @export
read_costs <- function(path = system.file("costs.csv", package = "dividefair")){
  readr::read_csv(path, show_col_types = FALSE) 
}
```

```{r example-read_costs}
data_costs <- dividefair::read_costs()
```

```{r test-read_costs}
data_costs <- dividefair::read_costs()
testthat::test_that("read_costs works properly with internal dataset", {
  testthat::expect_equal(nrow(data_costs), 5)
})
```



## Function to read the participants file
This is a helper function that reads in the data from the participant file
```{r function-read_participants}
#' Read and Process Participant Data from CSV
#'
#' This function reads a CSV file containing participant data, cleans and processes it,
#' and returns a tidy data frame. It allows for flexible column naming and handles
#' various CSV structures.
#'
#' @param path A string. The file path to the CSV file.
#' @param var_id A string. The name of the ID column in the CSV (default: "id").
#' @param var_age A string. The name of the age column in the CSV (default: "age").
#' @param var_group A string. The name of the group column in the CSV (default: "group").
#' @param var_adjustment A string. The name of the adjustment column in the CSV (default: "adjustment").
#' @param indicator_costs A string. The prefix for cost columns in the CSV (default: "cost_").
#' @param var_agegroup A string. The name of the age group column in the CSV (default: "agegroup").
#' @param value_adults A string. The value to use for adult age groups (default: "adult").
#' @param value_kids A string. The value to use for kid age groups (default: "kid").
#'
#' @return A tibble (data frame) containing the processed participant data.
#'
#' @details
#' The function performs the following operations:
#' 1. Reads the CSV file
#' 2. Cleans column names
#' 3. Renames columns based on user-provided names
#' 4. Processes the age group column, categorizing into adults and kids
#' 5. Pivots cost columns into a long format
#'
#'
#' @import dplyr
#' @import tidyr
#' @import readr
#' @import janitor
#' @importFrom rlang sym
#'
#' @export
read_participants <- function(path = system.file("participants.csv", package = "dividefair"),
                      var_id = "id",
                      var_age = "age",
                      var_group = "group",
                      var_adjustment = "adjustment",
                      var_agegroup = "agegroup",
                      indicator_costs = "cost_",
                      value_adults = "adult",
                      value_kids = "kid") {
  
  # Define patterns for adults and kids in both English and German
  adult_patterns <- tolower(c("adult", "adults", "erwachsene", "erwachsenen"))
  kid_patterns <- tolower(c("kid", "kids", "kind", "kinder"))
  
  # Read the CSV file
  data <- readr::read_csv(path, show_col_types = FALSE)
  
  # Clean column names
  data <- janitor::clean_names(data)
  
  # Rename columns based on user-provided names
  data <- data %>%
    dplyr::rename(
      id = !!rlang::sym(var_id),
      age = !!rlang::sym(var_age),
      group = !!rlang::sym(var_group),
      adjustment = !!rlang::sym(var_adjustment),
      !!var_agegroup := !!rlang::sym(var_agegroup)
    )
  
  # Process the agegroup column
  data <- data %>%
    dplyr::mutate(!!var_agegroup := dplyr::case_when(
      tolower(!!rlang::sym(var_agegroup)) %in% adult_patterns ~ value_adults,
      tolower(!!rlang::sym(var_agegroup)) %in% kid_patterns ~ value_kids,
      TRUE ~ !!rlang::sym(var_agegroup) # Keep the original value if it doesn't match
    ))
  
  # Identify cost columns
  cost_cols <- grep(paste0("^", indicator_costs), names(data), value = TRUE)
  
  # Pivot longer for cost columns
  data <- data %>%
    tidyr::pivot_longer(all_of(cost_cols), names_to = "cost_type", values_to = "share")
  
  return(data)
}


```


```{r examples-read_participants}
data_participants <- read_participants()

```

```{r tests-read_participants}
# Test with your dataset in "inst/"
data_participants <- read_participants()
data_costs <- dividefair::read_costs()
# Apply test on my function
testthat::test_that("read_participants works properly with internal dataset", {
  testthat::expect_equal(nrow(data_participants), 124)
})

# testthat::test_that("All IDs in costs are also in the participants file ", {
#   testthat::expect_true(all(data_costs$id %in% data_participants$id))
# })

```


## Function to check conformity of dataset
This is a helper function that checks if the two data files are in the right format


## Function to change the categorical values to numerical values 
This is a helper function that is used in the read_participants function. In the cost variables we accept categorical values. These categorical values need to be turned into numeric values 

```{r function-cat_to_num}
#' Change Categorical Values to Numeric
#'
#' This function converts categorical descriptive values in the columns `share`, `adjustment`, and `age` to numeric values.
#'
#' @param data_participants A dataframe containing the columns `share`, `adjustment`, and `age`.
#' @param share_reduced A numeric value to assign when `share` is "reduced". Default is `0.7`.
#' @param adjustment_less A numeric value to assign when `adjustment` is "less". Default is `0.8`.
#' @param adjustment_more A numeric value to assign when `adjustment` is "more". Default is `1.2`.
#'
#' @return A dataframe with transformed values.
#' @export
cat_to_num <- function(data_participants = read_participants(), 
                                          share_reduced = 0.7, 
                                          adjustment_less = 0.8, 
                                          adjustment_more = 1.2) {
  
  # Keep in mind the case_when needs character on both sides. 
  share_reduced = as.character(share_reduced)
  adjustment_less = as.character(adjustment_less)
  adjustment_more = as.character(adjustment_more)
  
data_participants |> 
    dplyr::mutate(share = dplyr::case_when(
      is.na(.data$share) ~ "0",  
      .data$share == "full" ~ "1",
      .data$share == "reduced" ~ "0.7",
      TRUE ~ .data$share
    )) |>
    dplyr::mutate(share = as.numeric(.data$share)) |> 
  dplyr::mutate(adjustment = dplyr::case_when(
    .data$adjustment == "more" ~ adjustment_more,
    .data$adjustment == "less" ~ adjustment_less,
    is.na(.data$adjustment) ~ "1",
    TRUE ~ .data$adjustment
    )) |>
  dplyr::mutate(adjustment = as.numeric(.data$adjustment)) |> 
    dplyr::mutate(age = dplyr::case_when(
      is.na(.data$age) ~ 18,
      TRUE ~ as.numeric(.data$age)
    ))
}
```

```{r examples-cat_to_num}
data_participants <- cat_to_num(data_participants = read_participants(), 
                                          share_reduced = 0.7, 
                                          adjustment_less = 0.8, 
                                          adjustment_more = 1.2)
```


```{r tests-cat_to_num}
data_participants <- cat_to_num()
testthat::test_that("The function change categorical to numeric works fine", {
  testthat::expect_equal(is.numeric(data_participants$adjustment), TRUE)
})
```






## Function to collect some basic stats 
This function collects some basic stats about the activity and the participants
```{r function-get_stats}
#' Get Statistics on Participants
#'
#' This function calculates statistics regarding the number of adults, children, stays, and absences
#' in a given data frame based on the `agegroup` and `share` columns.
#'
#' @param data_participants A data frame containing at least the following columns:
#'   - `agegroup`: A character vector indicating whether the participant is an "adult" or a "kid".
#'   - `share`: A character vector indicating presence with values "x" for stays and "n" for absences.
#'
#' @return A list containing:
#'   - `adults`: The total number of adults in the data frame.
#'   - `children`: The total number of children in the data frame.
#'
#'
#' @export
get_stats <- function(data_participants = read_participants()) {
  stats <- list()
  stats$adults <- sum(data_participants$agegroup == "adult" , na.rm = TRUE)
  stats$children <- sum(data_participants$agegroup == "kid", na.rm = TRUE)
  return(stats)
}
```

```{r examples-get_stats}
stats <- get_stats(read_participants())

```

```{r tests-get_stats}
data_participants <- read_participants()
testthat::test_that("The function get stats works fine", {
  testthat::expect_equal(get_stats(data_participants)$adults, 88)
})
```

## Function to calculate the share
```{r function-divide_costs}
#' Divide Costs Based on Weighted Factors
#'
#' This function calculates how much each individual should pay, based on various weighted factors such as age group, adjustment, and presence.
#'
#' @param data_participants A dataframe containing the columns `agegroup`, `age`, `adjustment`, and `share`. Default is `data_participants`.
#'
#' @return A dataframe with an additional column `costs_produced`, representing the calculated cost each individual needs to pay based on their weight.
#' @details The function computes a `weight` for each individual based on:
#'   - Initializing `weight` to `1`.
#'   - If `agegroup` is `"kid"`, the weight is updated to `weight * 0.0555 * age`.
#'   - The weight is further multiplied by values in `adjustment` and `share` columns.
#'   - The total cost (`cost`) is divided based on the sum of weights to determine each individual's share.
#'
#' @importFrom dplyr mutate case_when
#' @export
divide_costs <- function(data_participants = read_participants() |> cat_to_num()) {
  data_participants |> 
    dplyr::mutate(weight = 1) |> 
    dplyr::mutate(weight = dplyr::case_when(
      .data$agegroup == "kid" ~ .data$weight * 0.0555 * .data$age,
      TRUE ~ .data$weight
    )) |> 
    dplyr::mutate(weight = .data$weight * .data$adjustment) |> 
    dplyr::mutate(weight = .data$weight * .data$share) |> 
    dplyr::mutate(weight = as.numeric(.data$weight)) 
}
```

```{r example-divide_costs}
data_participants <- divide_costs()
```

```{r tests-divide_costs}
data_participants <- divide_costs()
testthat::test_that("The function divide costs works properly with internal dataset", {
  testthat::expect_equal(sum(data_participants$weight), 67.553)
})
```


## Function to minimize payments between payers and recievers
This is a helper function. We will recieve people who will recieve money and people who will need to pay money. We need to match those by also reducing the number of payments. 

```{r, function-minimize_payments}
#' Minimize Payments Between persons
#'
#' This function finds the minimum number of transactions required to settle balances between persons where some persons owe money and others need to be paid. It first settles exact matches where a payer owes the exact amount that a receiver needs, and then proceeds to match payers with receivers in a way that minimizes the number of payments.
#'
#' @param df A tibble or data frame with two columns: 
#'   \describe{
#'     \item{person}{A character vector representing the person IDs (e.g., names).}
#'     \item{to_pay}{A numeric vector representing the amount each person needs to pay (positive values) or receive (negative values).}
#'   }
#'
#' @return A tibble with three columns:
#'   \describe{
#'     \item{payer}{The person that is making a payment.}
#'     \item{receiver}{The person that is receiving the payment.}
#'     \item{amount}{The amount of money being transferred.}
#'   }
#'
#' @details 
#' The function separates the input data frame into payers (persons with positive balances) and receivers (persons with negative balances). It first identifies and settles any exact matches between payers and receivers. Then, for the remaining balances, it matches payers with receivers in a way that minimizes the number of payments.
#'
#' @export
# Function to calculate payments
minimize_payments <- function(df) {
  # Separate into payers and receivers
  payers <- df %>% filter(.data$to_pay > 0) %>% arrange(desc(.data$to_pay))
  receivers <- df %>% filter(.data$to_pay < 0) %>% arrange(.data$to_pay)
  
  # Initialize result data frame to store who pays whom
  payments <- tibble(payer = character(), receiver = character(), amount = numeric())
  
  # Step 1: Settle exact matches first
  i <- 1
  while (i <= nrow(payers)) {
    for (j in 1:nrow(receivers)) {
      if (payers$to_pay[i] == abs(receivers$to_pay[j])) {
        # Record the exact match payment
        payments <- payments %>%
          add_row(payer = payers$person[i], receiver = receivers$person[j], amount = payers$to_pay[i])
        
        # Remove the matched payer and receiver
        payers <- payers[-i,]
        receivers <- receivers[-j,]
        
        # Start loop again to avoid index shift issues
        i <- i - 1
        break
      }
    }
    i <- i + 1
  }
  
  # Step 2: Handle remaining payers and receivers
  i <- 1  # index for payers
  j <- 1  # index for receivers
  
  while (i <= nrow(payers) && j <= nrow(receivers)) {
    pay_amount <- min(payers$to_pay[i], abs(receivers$to_pay[j]))
    
    # Record the payment
    payments <- payments %>%
      add_row(payer = payers$person[i], receiver = receivers$person[j], amount = pay_amount)
    
    # Adjust balances
    payers$to_pay[i] <- payers$to_pay[i] - pay_amount
    receivers$to_pay[j] <- receivers$to_pay[j] + pay_amount
    
    # Move to the next payer/receiver if they are fully settled
    if (payers$to_pay[i] == 0) i <- i + 1
    if (receivers$to_pay[j] == 0) j <- j + 1
  }
  
  return(payments)
}
```

```{r example-minimize_payments}

df <- data.frame(
  person = c("Brown", "Smith", "Fisher", "Taylor", "Davis", "Johnson", "Wilson", "ORally"),
  to_pay = c(-995, -125, -80,  210, 245, 300, 365, 80)
)

minimize_payments(df)

```


```{r tests-minimize_payments}
library(dplyr)
df <- tibble(
  person = c("Brown", "Smith", "Fisher", "Taylor", "Davis", "Johnson", "Wilson", "ORally"),
  to_pay = c(-995, -125, -80,  210, 245, 300, 365, 80)
)

df_solved <- minimize_payments(df)

testthat::test_that("The function divide costs works properly with internal dataset", {
  testthat::expect_equal(df_solved[df_solved$payer == "Wilson", 3] |> pull(), 365)
})

testthat::test_that("The function divide costs works properly with internal dataset", {
  testthat::expect_equal(sum(df_solved$amount), 1200)
})
```


## Function to give you amount each has to pay

```{r function-divide_fairly}
#' Divide Costs Fairly Among Participants
#'
#' This function calculates the fair division of costs among participants based on their weights.
#' It reads the participants' and costs' data from files, calculates the total costs for each participant or group,
#' and returns the amounts to be paid after applying any payments that have already been made.
#'
#' @param participants_file Path to the CSV file containing participants' information. Defaults to a file within the package.
#' @param costs_file Path to the CSV file containing costs' information. Defaults to a file within the package.
#' @param pay_by A string specifying whether to divide costs by "group" or "individual". Defaults to "group".
#'
#' @return A data frame containing the final payments for each person or group after minimizing the payments.
#'
#' @details
#' The function starts by reading the participants and costs data. It calculates the total costs and
#' distributes them based on the participants' weights. It also considers the payments already made.
#' Depending on the `pay_by` argument, costs are divided either by group or by individual. The final step
#' involves minimizing the payments using the `minimize_payments` function.
#'
#' @import dplyr tidyr
#' @export
divide_fairly <- function(participants_file = system.file("participants.csv", package = "dividefair"), 
                          costs_file = system.file("costs.csv", package = "dividefair"),
                          pay_by = "group"){

  # Reading in the data
  data_participants <- read_participants() |> 
    cat_to_num() |> 
    divide_costs()
  data_costs <- read_costs()
  
  # Doing first calculations
  total_costs <- sum(data_costs$cost)
  total_weights <- sum(data_participants$weight)
  cost_per_weight <- total_costs / total_weights
  
  # Calculate costs_produced
  data_participants <- data_participants |> 
    dplyr::mutate(costs_produced = .data$weight * cost_per_weight) 
  
  # Summarise and add the costs
  if (pay_by == "group") {
    df <- data_participants |> 
      dplyr::group_by(.data$group) |> 
      dplyr::summarise(costs_produced = sum(.data$costs_produced))|> 
      dplyr::left_join(
        data_costs |> 
          dplyr::group_by(.data$group) |> 
          dplyr::summarise(payed = sum(.data$cost)),
        by = "group"
      ) |> 
      dplyr::mutate(payed = tidyr::replace_na(.data$payed, 0)) |> 
      dplyr::mutate(to_pay_unrounded = .data$costs_produced - .data$payed) |> 
      dplyr::mutate(to_pay = round(.data$to_pay_unrounded / 5) * 5) |> 
      dplyr::mutate(person = .data$group)
  } else if (pay_by == "individual") {
    df <- data_participants |> 
      dplyr::group_by(.data$id) |> 
      dplyr::summarise(costs_produced = sum(.data$costs_produced))|> 
      dplyr::left_join(
        data_costs |> 
          dplyr::group_by(.data$id) |> 
          dplyr::summarise(payed = sum(.data$cost)),
        by = "id"
      ) |> 
      dplyr::mutate(payed = tidyr::replace_na(.data$payed, 0)) |> 
      dplyr::mutate(to_pay_unrounded = .data$costs_produced - .data$payed) |> 
      dplyr::mutate(to_pay = round(.data$to_pay_unrounded / 5) * 5) |> 
      dplyr::mutate(person = as.character(.data$id))
  }
  
  # Apply the minimize_payment function
  results <- minimize_payments(df |> dplyr::select(.data$person, .data$to_pay))
  
  return(results)
}



```

```{r example-divide_fairly}
result <- divide_fairly(pay_by = "group")
```

```{r tests-divide_fairly}

result <- divide_fairly(pay_by = "group")
testthat::test_that("The function divide costs works properly with internal dataset", {
  testthat::expect_equal(sum(result$amount), 1120)
})

```

