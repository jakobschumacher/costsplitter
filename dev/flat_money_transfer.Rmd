---
title: "flat_money_transfer.Rmd for working package"
output: html_document
editor_options: 
  chunk_output_type: console
---

# This is the documentation of all functions of the package

```{r development-dataset}
# Run all this chunk in the console directly
# There already is a dataset in the "inst/" directory
# Make the dataset file available to the current Rmd during development
pkgload::load_all(path = here::here(), export_all = FALSE)

```



## Function to minimize payments between payers and recievers
This is a helper function. Some people will recieve money and others will need to pay money. We need to match these payers and recievers. We do this and try to reduce the number of overall payments. 

```{r, function-minimize_payments}
#' Minimize Payments Between persons
#'
#' This function finds the minimum number of transactions required to settle balances between persons where some persons owe money and others need to be paid. It first settles exact matches where a payer owes the exact amount that a receiver needs, and then proceeds to match payers with receivers in a way that minimizes the number of payments.
#'
#' @param df A tibble or data frame with two columns: 
#'   \describe{
#'     \item{person}{A character vector representing the person IDs (e.g., names).}
#'     \item{to_pay}{A numeric vector representing the amount each person needs to pay (positive values) or receive (negative values).}
#'   }
#'
#' @return A tibble with three columns:
#'   \describe{
#'     \item{payer}{The person that is making a payment.}
#'     \item{receiver}{The person that is receiving the payment.}
#'     \item{amount}{The amount of money being transferred.}
#'   }
#'
#' @details 
#' The function separates the input data frame into payers (persons with positive balances) and receivers (persons with negative balances). It first identifies and settles any exact matches between payers and receivers. Then, for the remaining balances, it matches payers with receivers in a way that minimizes the number of payments.
#'
#' @export
# Function to calculate payments
minimize_payments <- function(df = data_tosplit) {
  # Separate into payers and receivers
  payers <- df |> dplyr::filter(to_pay > 0) |> dplyr::arrange(desc(to_pay))
  receivers <- df |> dplyr::filter(to_pay < 0) |> dplyr::arrange(to_pay)
  
  # Initialize result data frame to store who pays whom
  payments <- dplyr::tibble(payer = character(), receiver = character(), amount = numeric())
  
  # Step 1: Settle exact matches first
  i <- 1
  while (i <= nrow(payers)) {
    for (j in 1:nrow(receivers)) {
      if (payers$to_pay[i] == abs(receivers$to_pay[j])) {
        # Record the exact match payment
        payments <- payments |>
          add_row(payer = payers$element[i], receiver = receivers$element[j], amount = payers$to_pay[i])
        
        # Remove the matched payer and receiver
        payers <- payers[-i,]
        receivers <- receivers[-j,]
        
        # Start loop again to avoid index shift issues
        i <- i - 1
        break
      }
    }
    i <- i + 1
  }
  
  # Step 2: Handle remaining payers and receivers
  i <- 1  # index for payers
  j <- 1  # index for receivers
  
  while (i <= nrow(payers) && j <= nrow(receivers)) {
    pay_amount <- min(payers$to_pay[i], abs(receivers$to_pay[j]))
    
    # Record the payment
    payments <- payments |>
      add_row(payer = payers$element[i], receiver = receivers$element[j], amount = pay_amount)
    
    # Adjust balances
    payers$to_pay[i] <- payers$to_pay[i] - pay_amount
    receivers$to_pay[j] <- receivers$to_pay[j] + pay_amount
    
    # Move to the next payer/receiver if they are fully settled
    if (payers$to_pay[i] == 0) i <- i + 1
    if (receivers$to_pay[j] == 0) j <- j + 1
  }
  
  return(payments)
}
```

```{r example-minimize_payments}

df <- dplyr::tibble(
  element = c("Brown", "Smith", "Fisher", "Taylor", "Davis", "Johnson", "Wilson", "ORally"),
  to_pay = c(-995, -125, -80,  210, 245, 300, 365, 80)
)

minimize_payments(df)

```


```{r tests-minimize_payments}
library(dplyr)
df <- dplyr::tibble(
  element = c("Brown", "Smith", "Fisher", "Taylor", "Davis", "Johnson", "Wilson", "ORally"),
  to_pay = c(-995, -125, -80,  210, 245, 300, 365, 80)
)



df_solved <- minimize_payments(df)

testthat::test_that("The function divide costs works properly with internal dataset", {
  testthat::expect_equal(df_solved[df_solved$payer == "Wilson", 3] |> pull(), 365)
})

testthat::test_that("The function divide costs works properly with internal dataset", {
  testthat::expect_equal(sum(df_solved$amount), 1200)
})

df2 <- dplyr::tibble(
  element = c("Brown", "Smith", "Fisher", "Taylor", "Davis", "Johnson", "Wilson", "ORally"),
  to_pay = c(-995, -125, -85,  210, 245, 300, 360, 80)
) |> minimize_payments()

testthat::test_that("The function divide costs works properly with internal dataset", {
  testthat::expect_equal(df_solved[df_solved$payer == "Wilson", 3] |> pull(), 365)
})


```


## Function to give you amount each has to pay

```{r function-costsplitter}
#' Divide Costs Fairly Among Participants
#'
#' This function calculates the fair division of costs among participants based on their weights.
#' It reads the participants' and costs' data from files, calculates the total costs for each participant or group,
#' and returns the amounts to be paid after applying any payments that have already been made.
#'
#' @param data The dataset 
#' @param pay_by A string specifying whether to divide costs by "group" or "individual". Defaults to "group".
#'
#' @return A data frame containing the final payments for each person or group after minimizing the payments.
#'
#'
#' @import dplyr tidyr
#' @export
costsplitter <- function(data = readr::read_csv(system.file("participants.csv", package = "costsplitter"), show_col_types = FALSE), 
                         pay_by = "individual", 
                         var_pay = "pay_", 
                         var_share = "share_",
                         age_adjustment = (1 / 18),
                        share_adult = 1,
                        share_kid = 0.5,
                        share_full = 1, 
                        share_reduced = 0.7, 
                        share_less = 0.8, 
                        share_more = 1.2
                         ...){

# Make sure that the columns are correctly takes as character
data <- rio::import(here::here("..", "Abrechnung.xlsx")) |>
        dplyr::tibble() |>
        dplyr::mutate(across(starts_with("share_"), as.character)) |>
        dplyr::mutate(across(starts_with("age"), as.character)) 


# Check if 'name' column exists and is unique
  if (!"name" %in% colnames(data)) {
    stop("The 'name' column is missing.")
  }

  if (anyDuplicated(data$name)) {
    stop("The 'name' column contains duplicate entries.")
  }

  # Check for at least one 'pay_' column
  pay_cols <- grep(paste0("^", var_pay), colnames(data), value = TRUE)
  if (length(pay_cols) == 0) {
    stop("At least one 'pay_' column must be present.")
  }

  # Validate 'age' column
  if ("age" %in% colnames(data)) {
    age_values <- data$age
    if (all(age_values %in% c(NA, "", "adult", "kid") | (is.numeric(age_values) & age_values <= 0 & age_values >= 120))) {
      stop("The 'age' column must be a number between 0 and 120, or 'adult' or 'kid'.")
    }
  }

  # Validate 'adjustment' column
  if ("adjustment" %in% colnames(data)) {
    adjustment_values <- data$adjustment
    if (all(!(adjustment_values %in% c(NA, "", "more", "less")) | (is.numeric(adjustment_values) & adjustment_values <= 0 & adjustment_values >= 100))) {
      stop("The 'adjustment' column must be a number between 0 and 100 or categorical ('more', 'less').")
    }
  }



# Convert shares to characters for case_when
  share_reduced_character = as.character(share_reduced)
  share_adult_character = as.character(share_adult * 18)
  share_kid_character = as.character(share_kid * 18)
  share_full_character = as.character(share_full)
  share_less_character = as.character(share_less)
  share_more_character = as.character(share_more)
  
  # Define patterns for adults and kids in both English and German
  adult_patterns <- tolower(c("adult", "adults", "erwachsene", "erwachsenen"))
  kid_patterns <- tolower(c("kid", "kids", "kind", "kinder"))

# Change categorical values to numerical values
  data <- data |>
    dplyr::mutate(across(tidyr::starts_with("share_"), ~ as.numeric(dplyr::case_when(
      is.na(.) | . == "" ~ "0",
      . == "full" ~ "1",
      . == "reduced" ~ share_reduced_character,
      TRUE ~ .
    )))) |>
    # Age
    dplyr::mutate(age = dplyr::case_when(
      is.na(.data$age) | .data$age == "" ~ "18",
      .data$age %in% adult_patterns ~ share_adult_character,
      .data$age %in% kid_patterns ~ share_kid_character,
      TRUE ~ .data$age
    )) |> 
    dplyr::mutate(age = as.numeric(.data$age)) |> 
    dplyr::mutate(age = round(.data$age * age_adjustment, 2)) |>
    # Adjustment
    dplyr::mutate(adjustment = dplyr::case_when(
      is.na(.data$adjustment) | .data$adjustment == "" ~ "1",
      .data$adjustment == "more" ~ share_more_character,
      .data$adjustment == "less" ~ share_less_character,
      TRUE ~ .data$adjustment
    )) |>
    dplyr::mutate(adjustment = as.numeric(.data$adjustment)) 




    # Reading in the data
    data <- data |>
        dplyr::mutate(across(starts_with("share_"), ~ . * .data$age * .data$adjustment)) 

    # Split the dataset into participants data and a dataset showing what everybody paid
    data_participants <- data |> 
        dplyr::select(.data$name, .data$group, dplyr::starts_with("share_")) |>
        tidyr::pivot_longer(cols = dplyr::starts_with("share_"), names_to = "activity", values_to = "costs") |>
        dplyr::mutate(activity = stringr::str_split_i(.data$activity, pattern = "_", 2))

    data_costs <- dplyr::left_join(
        names(data) |> 
            stringr::str_subset("^share_") |> 
            purrr::map_dfr(~ data |> 
                dplyr::summarise(activity = .x, total_units = sum(.data[[.x]], na.rm = TRUE))) |>
            dplyr::mutate(activity = stringr::str_remove(.data$activity, "^share_")),
        names(data) |> 
            stringr::str_subset("^pay_") |>
            purrr::map_dfr(~ data |> 
                dplyr::summarise(activity = .x, total_payed = sum(.data[[.x]], na.rm = TRUE))) |>
            dplyr::mutate(activity = stringr::str_remove(.data$activity, "^pay_")), by = "activity"
    ) |> 
    dplyr::mutate(cost_per_unit = .data$total_payed / .data$total_units) |>
    dplyr::select(.data$activity, .data$cost_per_unit)

    # Combine the dataset
    data_topay <- data_participants |>
        dplyr::left_join(data_costs, by = "activity") |>
        dplyr::mutate(topay = .data$costs * .data$cost_per_unit)

    # Get the data_topay and data_recieves
    data_topay <- if(pay_by == "group"){
        data_topay |>
            dplyr::group_by(.data$group) |>
            dplyr::summarise(to_pay = sum(.data$topay)) |>
            dplyr::rename(element = .data$group)
    } else {
        data_topay |>
            dplyr::group_by(.data$name) |>
            dplyr::summarise(to_pay = sum(.data$topay)) |>
            dplyr::rename(element = .data$name)
    }

    data_recieves <- if(pay_by == "group"){
        data |>
            dplyr::select(.data$group, dplyr::starts_with("pay_")) |>
            tidyr::pivot_longer(cols = dplyr::starts_with("pay"), names_to = "activity", values_to = "payed") |>
            dplyr::group_by(.data$group) |>
            dplyr::summarise(recieves = sum(.data$payed, na.rm = TRUE)) |>
            dplyr::rename(element = .data$group)
    } else {
        data |>
            dplyr::select(.data$name, dplyr::starts_with("pay_")) |>
            tidyr::pivot_longer(cols = dplyr::starts_with("pay"), names_to = "activity", values_to = "payed") |>
            dplyr::group_by(.data$name) |>
            dplyr::summarise(recieves = sum(.data$payed, na.rm = TRUE)) |>
            dplyr::rename(element = .data$name)
    }

    # Combine the data again
    data_tosplit <- data_topay |> 
        dplyr::left_join(data_recieves, by = "element") |>
        dplyr::mutate(to_pay = .data$to_pay - .data$recieves) |>
        dplyr::select(.data$element, .data$to_pay)

    # Apply the minimization function from above
    results <- minimize_payments(data_tosplit) 

    return(results)
}
```

```{r example-costsplitter}
result <- costsplitter(pay_by = "group")
```

```{r tests-costsplitter}

result <- costsplitter(pay_by = "individual")
testthat::test_that("The function divide costs works properly with internal dataset", {
  testthat::expect_equal(sum(result$amount), 1120)
})

```

